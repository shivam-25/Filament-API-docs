---
title: API Reference

language_tabs: # must be one of https://github.com/rouge-ruby/rouge/wiki/List-of-supported-languages-and-lexers
  - python
  - javascript

toc_footers:
  - <a href='#'>Sign Up for a API Key</a>

includes:
  - errors

search: true

code_clipboard: true

meta:
  - name: description
    content: Documentation for the Filament API
---

# Introduction

Welcome to the Filament API documentation! 

Filament supports REST and Websocket API.

REST API Endpoints:

Mainnet: https://api.filament.finance

Testnet: https://api-testnet.filament.finance

Websocket API Endpoints:

Mainnet: wss://ws.filament.finance

Testnet: wss://ws-testnet.filament.finance

Requests are all JSON objects. 
Responses are either a JSON object or array.

# API Key Setup

## Via UI

Will be updated soon.

## Via API

> Generate signing_key:

```javascript
const signer = ethers.Wallet.createRandom()
```

> Generate account_signature:

```javascript
// First we hash the register data
const registerHash = ethers.utils._TypedDataEncoder.hash(
    {
      name: "Filament Mainnet",
      version: "1",
      chainId: 1,
    },
    {
      Register: [
        { name: "key", type: "address" },
        { name: "expiry", type: "uint256" },
      ],
    },
    {
      key: await signer.getAddress(),
      expiry: ethers.constants.MaxUint256.toString(),
    }
);

// Then we sign the hash
const res = await promisify(provider.provider.sendAsync)({
  method: "eth_sign",
  params: [account.toLowerCase(), registerHash],
});


// This is the account_signature
const accountSignature = res.result;
```

> Generate signing_key_signature:

```javascript
// This is the signing_key_signature
const signingKeySignature = await signer._signTypedData(
    {
      name: "Filament Mainnet",
      version: "1",
      chainId: 1,
    },
    {
      SignKey: [{ name: "account", type: "address" }],
    },
    {
      account: your_wallet_address
    }
);
```
A new API key can be generated by calling the /register endpoint.

The endpoint requires the following parameters:

* account: the account's Ethereum address
* signing_key: a randomly generated Ethereum address
* expiry: UNIX timestamp in nanoseconds
* account_signature: signature generated using the account's private key
* signing_key_signature: signature generated using the signing_key's private key

To generate the signing_key, account_signature and signing_key_signature, you can follow the example code below:



# Signing Orders

To create an order, a signature needs to be generated. This signature allows for the gasless trading experience in Filament. The signature generation used by Filament follows the guideline laid out in the EIP-712 (https://eips.ethereum.org/EIPS/eip-712) . This signing method is widely used and supported in most wallets.

> For authorize example, use this code snippet:

```python
from web3 import Web3, EthereumTesterProvider
from web3.auto import w3
from eth_account.messages import encode_structured_data

# Function to generate a random signing key
def create_signing_key():
  return w3.eth.account.create()

# Sign the order using EIP-712 structured data
def sign_order(order, signing_key):
  domain = {
    'name': 'Filament Mainnet',
    'version': '1',
    'chainId': 1,
  }
  types = {
    'Order': [
      {'name': 'account', 'type': 'address'},
      {'name': 'indexToken', 'type': 'address'},
      {'name': 'isBuy', 'type': 'bool'},
      {'name': 'size', 'type': 'uint256'},
      {'name': 'reduceOnly', 'type': 'bool'},
      {'name': 'referralCode', 'type': 'string'}
    ]
  }
  message = {
    'account': order['account'],
    'indexToken': order['indexToken'],
    'isBuy': order['isBuy'],
    'size': order['size'],
    'reduceOnly': order['reduceOnly'],
    'referralCode': order['referralCode']
  }

  encoded_data = encode_structured_data(domain, types, message)
  signature = signing_key.sign_message(encoded_data)
  return signature.signature.hex()

def main():
  # Create a random signing key
  signing_key = create_signing_key()

  # Define the order
  order = {
    'account': '0xYourAccountAddress',
    'indexToken': 'BTC|ETH etc.',
    'isBuy': True,
    'size': int(Web3.toWei(1.000000, 'ether')),  # Example size converted to wei for Ethereum
    'leverage': '10',
    'reduceOnly': False,
    'referralCode': 'REF12345',
    'orderType': {
      'limit': {
        'tif': 'Gtc'  # Example of a limit order type with "Good Till Canceled"
        }
    }
  }

  # Sign the order
  signature = sign_order(order, signing_key)
  print('Order Signature:', signature)

  # Construct the full order payload
  payload = {
    'type': "order",
    'orders': [{
      **order,
      'signature': signature,
      'signingKey': signing_key.address
    }]
  }

  print('Payload to send:', payload)
  # Here you would implement the logic to send the payload to your off-chain order book via REST API or similar

if __name__ == '__main__':
  main()

```

```javascript
import { ethers } from 'ethers';

async function getProvider() {
    if (typeof window.ethereum !== 'undefined') {
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        return new ethers.providers.Web3Provider(window.ethereum);
    } else {
        console.error("Ethereum provider not found");
    }
}

// Generate a separate signing key
function createSigningKey() {
    return ethers.Wallet.createRandom();
}

async function signOrder(order, signingKey) {
    const domain = {
        name: "Filament Mainnet",
        version: "1",
        chainId: 1,  // Adjust based on your network (Ethereum Mainnet is 1)
    };

    const types = {
        Order: [
            { name: "account", type: "address" },
            { name: "indexToken", type: "string" },
            { name: "isBuy", type: "bool" },
            { name: "size", type: "uint256" },
            { name: "reduceOnly", type: "bool" },
            { name: "referralCode", type: "string" }
        ]
    };

    const value = {
        account: order.account,
        indexToken: order.indexToken,
        isBuy: order.isBuy,
        size: ethers.utils.parseUnits(order.size.toString(), 18), // Assuming 18 decimal precision
        reduceOnly: order.reduceOnly,
        referralCode: order.referralCode,
    };

    // Signing the immutable parts of the order with the signing key
    const signature = await signingKey._signTypedData(domain, types, value);
    return signature;
}

async function main() {
    const provider = await getProvider();
    const userSigner = provider.getSigner();
    const signingKey = createSigningKey(); // This creates a new random wallet for signing purposes

    const order = {
        account: '0xYourAccountAddress'
        indexToken: 'BTC|ETH',
        isBuy: true,
        size: '1.000000',  // Example size with up to 6 decimal places
        leverage: '10',    // Example leverage
        reduceOnly: false,
        referralCode: 'REF12345',
        orderType: {
            limit: {
                tif: 'Gtc'  // Example of a limit order type with "Good Till Canceled"
            },
            // Uncomment if using a trigger order type
            // trigger: {
            //     triggerPrice: '500.000000',
            //     stopLossPrice: '450.000000',
            //     takeProfitPrice: '550.000000',
            //     isMarket: false,
            //     tpsl: 'both'
            // }
        }
    };

    const signature = await signOrder(order, signingKey);
    console.log('Order Signature:', signature);

    // Construct the full order payload
    const payload = {
        type: "order",
        orders: [{
            ...order,
            signature: signature,
            signingKey: signingKey.address
        }]
    };

    console.log('Payload to send:', payload);
    // Here you would send the payload to your off-chain order book via REST API or similar
}

main();
```
<aside class="notice">
The signature generated for order submission is different from the signature for authentication.
</aside>

# Filament

## Registers a new account. 

```python
import requests
import time

# Suppose this is the user's Ethereum address and a signing key address
account = '0x123abc...'  # Replace with actual Ethereum address
signing_key = '0x456def...'  # Replace with the Ethereum address of the signing key
# UNIX timestamp for 24 hours from now
expiry = int(time.time()) + (24 * 60 * 60)
# Placeholder signatures, in practice these would be obtained by signing the transaction
account_signature = '0x789ghi...'  # Replace with the actual EIP-712 signature of the account
signing_key_signature = '0x101jkl...'  # Replace with the actual EIP-712 signature of the signing key

url = "https://api.aevo.xyz/register"

payload = {
  "account": account,
  "signing_key": signing_key,
  "expiry": expiry,
  "account_signature": account_signature,
  "signing_key_signature": signing_key_signature,
  "referral_code": "your-referral-code"  # Replace with the actual referral code
}
headers = {
  "accept": "application/json",
  "content-type": "application/json"
}

response = requests.post(url, json=payload, headers=headers)

```

```javascript
const ethers = require('ethers');

async function registerAccount() {
    // Suppose this is the user's Ethereum address and a signing key address
    const account = '0x123abc...';  // Replace with actual Ethereum address
    const signingKey = '0x456def...';  // Replace with the Ethereum address of the signing key
    // UNIX timestamp for 24 hours from now
    const expiry = Math.floor(Date.now() / 1000) + (24 * 60 * 60);
    // Placeholder signatures, in practice these would be obtained by signing the transaction
    const accountSignature = '0x789ghi...';  // Replace with the actual EIP-712 signature of the account
    const signingKeySignature = '0x101jkl...';  // Replace with the actual EIP-712 signature of the signing key

    const options = {
      method: 'POST',
      headers: { accept: 'application/json', 'content-type': 'application/json' },
      body: JSON.stringify({
        account: account,
        signing_key: signingKey,
        expiry: expiry,
        account_signature: accountSignature,
        signing_key_signature: signingKeySignature,
        referral_code: 'your-referral-code'  // Replace with the actual referral code
      })
    };

    fetch('https://api.aevo.xyz/register', options)
      .then(response => response.json())
      .then(response => console.log(response))
      .catch(err => console.error(err));
}

registerAccount();

```

> The above command returns JSON structured like this:

```json
{
  "success": true,
  "signing_keys": [
    {
      "signing_key": "0xE9b3a48d15BE316A8e34FAd53fFDFDddf0C3D24b",
      "expiry": "1680249600000000000",
      "created_timestamp": "1680249600000000000"
    }
  ],
  "api_key": "URPtt6eNCXgL8ERuchphUretdaga2smF",
  "api_secret": "0140af7046a63530fc4bd319823d6eee98086ef0d446584b42f68b640b60c457",
  "read_only": true
}
```

This endpoint register's a new user.

### HTTP Request

`GET https://api.filament.finance/register`

### URL Payload

Parameter | Description
--------- | -----------
| `account`           | Account's Ethereum address.                                 |
| `signing_key`       | Ethereum address of the signing key.                        |
| `expiry`            | Signing key expiry in UNIX timestamp in seconds.            |
| `account_signature` | Hash of EIP-712 signature signed by the account.            |
| `signing_key_signature` | Hash of EIP-712 signature signed by the signing key.     |
| `referral_code`     | Referral Code (username of referrer) of the new account registration. |


## Place Order(s)

> Use this example snippet for place orders:

```python
import requests
import json

# Example payload based on the structure you provided
payload = {
  "type": "order",
  "orders": [{
    "account": "0xYourEthereumAddress",
    "indexToken": "0xTheTokenAddress",
    "isBuy": True,
    "size": "1.000000",
    "leverage": "10",
    "reduceOnly": False,
    "referralCode": "YourReferralCode",
    "orderType": {
      "limit": {
        "tif": "Gtc"
      }
      # include 'trigger' details if it's a trigger order
    }
  }],
  "signature": "0xYourOrderSignature"
}

# Set up the headers
headers = {
  "accept": "application/json",
  "content-type": "application/json"
}

# Make the POST request
response = requests.post('https://api.filament.finance/orders', data=json.dumps(payload), headers=headers)

# Print the response from the server
print(response.text)
```

```javascript
const fetch = require('node-fetch'); // If you're using Node.js; not needed for browsers

// Example payload based on the structure you provided
const payload = {
    "type": "order",
    "orders": [{
        "account": "0xYourEthereumAddress",
        "indexToken": "0xTheTokenAddress",
        "isBuy": true,
        "size": "1.000000",
        "leverage": "10",
        "reduceOnly": false,
        "referralCode": "YourReferralCode",
        "orderType": {
            "limit": {
                "tif": "Gtc"
            }
            // include 'trigger' details if it's a trigger order
        }
    }],
    "signature": "0xYourOrderSignature"
};

// Set up the headers
const headers = {
    "accept": "application/json",
    "content-type": "application/json"
};

// Make the POST request
fetch('https://api.filament.finance/orders', {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(payload)
})
.then(response => response.json())
.then(data => console.log(data))
.catch(err => console.error('Error:', err));

```

> The above code returns JSON structured like this:

```json
{
  "status":"ok",
  "response":{
    "type":"order",
    "orders": [
      {
        "status": "success",
        "orderId": "Unique Identifier",
        "account": "Ethereum Address",
        "indexToken": "Token Identifier",
        "isBuy": true or false,
        "size": "Decimal Value",
        "leverage": "Decimal Value",
        "reduceOnly": true or false,
        "referralCode": "Referral Code",
        "orderType": {
          "limit": {
            "tif": "Alo" | "Ioc" | "Gtc"
          }
        }
      }
    ]
  }
}
```

This endpoint post orders to filament.

### HTTP Request

`POST https://api.filament.finance/exchange`

### Query Payload

| Payload                           | Type      | Description                                                                                                  |
|-------------------------------------|-----------|--------------------------------------------------------------------------------------------------------------|
| `type`                              | String    | Action to place orders to orderbook.                                                                         |
| `account`                           | String    | The Ethereum address of the user making the order.                                                           |
| `indexToken`                        | String    | The identifier for the token being traded.                                                                   |
| `isBuy`                             | Boolean   | Set to `true` if the order is a buy order; `false` if it is a sell order.                                    |
| `size`                              | Decimal   | The size of the order, supporting up to 6 decimal places.                                                    |
| `leverage`                          | Decimal   | The leverage for the order, e.g., `10` for 10x leverage.                                                     |
| `reduceOnly`                        | Boolean   | If `true`, the order will only reduce a position.                                                            |
| `referralCode`                      | String    | A code that attributes the new account registration to the referrer.                                         |
| `orderType.limit.tif`               | String    | For limit orders, specifies the time in force: `Alo`, `Ioc`, or `Gtc`.                                       |
| `orderType.trigger.triggerPrice`    | Decimal | For trigger orders, the price at which the order is triggered.                                               |
| `orderType.trigger.stopLossPrice`   | Decimal | Optional. For trigger orders, the price to set a stop loss.                                                  |
| `orderType.trigger.takeProfitPrice` | Decimal | Optional. For trigger orders, the price to take profit.                                                      |
| `orderType.trigger.isMarket`        | Boolean   | Determines if the triggered order should be executed as a market order.                                      |
| `orderType.trigger.tpsl`            | String    | Specifies the type of trigger: `tp` for take profit, `sl` for stop loss, `na` for not applicable, or `both`. |
| `signature`                         | String    | The EIP-712 compliant signature of the order data, signed by the account.                                    |


<aside class="notice">
For order payload, either use

orderType.limit

or

orderType.trigger

</aside>

> The below code JSON shows either snippets:

```json
"orderType": {
  "limit": {
      "tif": "Alo" | "Ioc" | "Gtc" 
   }
}
```

```json
"orderType": {
  "trigger": {
    "triggerPrice": "Decimal Value (decimal part contain upto 6 decimal values)",
    "stopLossPrice": "Decimal Value (Optional, only present when tpsl = sl or both) (decimal part contain upto 6 decimal values)",
    "takeProfitPrice:": "Decimal Value (Optional, only present when tpsl = tp or both) (decimal part contain upto 6 decimal values)",
    "isMarket": "Boolean",
    "tpsl": "tp" | "sl" | "na" | "both"
  }
}
```


<aside class="success">
Each order within the `orders` array should contain the above parameters. The `signature` field is at the root level of the payload and should be a hash of the order payload signature signed by the user's account.
</aside>

## Cancel Order(s)

> Use this example snippet for cancel orders:

```python
import requests
import json

# Example payload for canceling an order
cancel_payload = {
  "type": "cancel",
  "cancels": [
    {
      "asset": "BTC",  # Replace with the actual asset symbol
      "orderId": "1234567890abcdef"  # Replace with the actual order ID to cancel
    }
    # Add more objects to cancel multiple orders
  ],
  "signature": "0xYourOrderSignature"
}

# Set up the headers
headers = {
  "accept": "application/json",
  "content-type": "application/json"
}

# Make the POST request to cancel orders
response = requests.post('https://api.filament.finance/exchange', json=cancel_payload, headers=headers)

# Print the response from the server
print(response.text)

```

```javascript
// Node.js users will need to require 'node-fetch'. Browser environments can skip this line.
const fetch = require('node-fetch'); // Only for Node.js

// Example payload for canceling an order
const cancelPayload = {
    "type": "cancel",
    "cancels": [
        {
            "asset": "BTC",  // Replace with the actual asset symbol
            "orderId": "1234567890abcdef"  // Replace with the actual order ID to cancel
        }
        // Add more objects to cancel multiple orders
    ],
    "signature": "0xYourOrderSignature"
};

// Set up the headers
const headers = {
    "accept": "application/json",
    "content-type": "application/json"
};

// Make the POST request to cancel orders
fetch('https://api.filament.finance/exchange', {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(cancelPayload)
})
.then(response => response.json())
.then(data => console.log(data))
.catch(err => console.error('Error:', err));
```

> The above command returns JSON structured like this:

```json
{
  "status":"ok",
  "response":{
    "type":"cancel",
    "canceledOrders":[
      {
        "orderId": "Unique Identifier",
        "status": "success"
      }
    ]
  }
}
```

This endpoint cancel order(s) using the order id.

<aside class="notice">
Order ids to be used to cancel orders.
</aside>

### HTTP Request

`POST https://api.filament.finance/exchange`

### URL Parameters

| Payload  | Type    | Description   
|----------|---------| -----------
| `type`           | String  | Action to cancel orders in orderbook.                                                                         |
| `asset`          | String  | The identifier for the token being traded.                                                          |
| `orderId`        | String  | Unique Identifier of orders placed.                                                                   |
| `signature`      | String    | The EIP-712 compliant signature of the order data, signed by the account.                                    |

## Update Leverage

> Use this example snippet for update leverage:

```python
import requests
import json

# Example payload for updating leverage
payload = {
  "type": "updateLeverage",
  "asset": "ETH",  # Replace with the actual token identifier
  "leverage": "5",  # Replace with the integer value representing new leverage
  "signature": "0xYourSignature"  # Replace with the EIP-712 signature
}

# Set up the headers
headers = {
  "accept": "application/json",
  "content-type": "application/json"
}

# Make the POST request
response = requests.post('https://api.filament.finance/exchange', data=json.dumps(payload), headers=headers)
```

```javascript
const fetch = require('node-fetch'); // Only for Node.js, not needed in modern browsers

// Example payload for updating leverage
const payload = {
    "type": "updateLeverage",
    "asset": "ETH",  // Replace with the actual token identifier
    "leverage": "5",  // Replace with the integer value representing new leverage
    "signature": "0xYourSignature"  // Replace with the EIP-712 signature
};

// Set up the headers
const headers = {
    "accept": "application/json",
    "content-type": "application/json"
};

// Make the POST request
fetch('https://api.filament.finance/exchange', {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(payload)
})
.then(response => response.json())
.then(data => console.log(data))
.catch(err => console.error('Error:', err));
```

> The above command returns JSON structured like this:

```json
{
  "status": "ok"
}
```

This endpoint updates isolated leverage on a coin.

### HTTP Request

`POST https://api.filament.finance/exchange`

### URL Payload

| Payload        | Type    | Description
|----------------|---------| -----------
| `type`         | String  | Action to updateLeverage.                                                                         |
| `asset`        | String  | The identifier for the token being traded.                                                          |
| `leverage`     | String  | Integer representing new leverage.   
| `signature`    | String  | The EIP-712 compliant signature of the order data, signed by the account.                                    |

## Update Isolated margin

> Use this example snippet for update isolated margin:

```python
import requests
import json

# Example payload for updating leverage
payload = {
  "type": "updateIsolatedMargin",
  "asset": "ETH",  # Replace with the actual token identifier
  "isBuy": "true",
  "ntli": "500.00",  #  float representing amount to add or remove
  "signature": "0xYourSignature"  # Replace with the EIP-712 signature
}

# Set up the headers
headers = {
  "accept": "application/json",
  "content-type": "application/json"
}

# Make the POST request
response = requests.post('https://api.filament.finance/exchange', data=json.dumps(payload), headers=headers)
```

```javascript
const fetch = require('node-fetch'); // Only for Node.js, not needed in modern browsers

// Example payload for updating leverage
const payload = {
    "type": "updateIsolatedMargin",
    "asset": "ETH",  // Replace with the actual token identifier
    "isBuy": "true",
     "ntli": "500.00",  //  float representing amount to add or remove
    "signature": "0xYourSignature"  // Replace with the EIP-712 signature
};

// Set up the headers
const headers = {
    "accept": "application/json",
    "content-type": "application/json"
};

// Make the POST request
fetch('https://api.filament.finance/exchange', {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(payload)
})
.then(response => response.json())
.then(data => console.log(data))
.catch(err => console.error('Error:', err));
```

> The above command returns JSON structured like this:

```json
{
  "status": "ok"
}
```

This endpoint is to add or remove margin from isolated position.

### HTTP Request

`POST https://api.filament.finance/exchange`

### URL Payload

| Payload     | Type    | Description
|-------------|---------| -----------
| `type`      | String  | Action to updateIsolatedMargin.                                                                         |
| `asset`     | String  | The identifier for the token being traded.                                                          |
| `isBuy`     | Boolean | true/false.
| `ntli`      | Float   | Float representing amount to add or remove.
| `signature` | String  | The EIP-712 compliant signature of the order data, signed by the account.                                    |
